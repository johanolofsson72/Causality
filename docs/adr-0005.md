# ADR-0005: Caching and Metrics for Query Execution

## Context
Executing queries directly against the database can be expensive, especially if:
- The same queries are repeated frequently.
- Large datasets are scanned without changes between requests.
- No monitoring exists for query latency or failures.

Without caching and metrics, we risk poor performance, unnecessary database load, and lack of visibility into system behavior.

---

## Decision
We introduce a **caching and metrics layer** around query execution:

### Caching
- **Result cache**: Responses to idempotent queries are cached by a stable hash of the Abstract Query (AQ).
- **Cache invalidation**: Cache entries are invalidated on data changes (write operations).
- **Scope**: Default TTL of 60 seconds; configurable per entity.
- **Storage**: In-memory (MemoryCache) for POC; extensible to Redis or distributed cache.

### Metrics
- Collect Prometheus-compatible metrics for:
  - `query_latency_ms` (histogram of execution times).
  - `query_cache_hit_ratio` (gauge).
  - `query_blocked_total` (counter, labeled by reason).
  - `query_executed_total` (counter).
- Metrics exposed via `/metrics` endpoint for scraping by Prometheus/Grafana.

### Audit
- Every executed query is logged with:
  - User ID
  - Tenant ID
  - Entity
  - Query hash
  - Execution time
  - Result count
  - Validation outcome (allowed/blocked)

---

## Consequences
- **Performance**: Frequently repeated queries are served faster with reduced DB load.
- **Visibility**: Metrics provide insights into performance and usage patterns.
- **Compliance**: Audit trail supports governance and incident investigation.
- **Complexity**: Adds cache invalidation and monitoring infrastructure that must be maintained.

---

## Status
Accepted â€“ mandatory for production-ready query execution.
